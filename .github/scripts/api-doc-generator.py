#!/usr/bin/env python3
"""
API Documentation Generator

–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –∏–∑ Python –∫–æ–¥–∞
—Å–æ–≥–ª–∞—Å–Ω–æ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ Enhanced GitHub-Native Documentation System.
"""

import ast
import os
import re
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any


class APIDocumentationGenerator:
    """
    Generate API documentation automatically from code
    """

    def __init__(self, source_dir: str = ".", output_dir: str = "docs/api"):
        self.source_dir = Path(source_dir)
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.api_endpoints: List[Dict[str, Any]] = []
        self.classes: List[Dict[str, Any]] = []
        self.functions: List[Dict[str, Any]] = []

    def discover_api_endpoints(self) -> List[Dict[str, Any]]:
        """Scan code –¥–ª—è API endpoints"""
        print("üîç Discovering API endpoints...")

        endpoints: List[Dict[str, Any]] = []

        # Scan Python files for API patterns
        for python_file in self.source_dir.rglob("*.py"):
            if "test" in str(python_file) or "__pycache__" in str(python_file):
                continue

            try:
                with open(python_file, "r", encoding="utf-8") as f:
                    content = f.read()

                # Parse AST for detailed analysis
                tree = ast.parse(content, filename=str(python_file))

                for node in ast.walk(tree):
                    # Look for class definitions (potential API classes)
                    if isinstance(node, ast.ClassDef):
                        class_info = self._extract_class_info(node, python_file)
                        if class_info:
                            self.classes.append(class_info)

                    # Look for function definitions (potential API methods)
                    elif isinstance(node, ast.FunctionDef):
                        func_info = self._extract_function_info(node, python_file)
                        if func_info:
                            self.functions.append(func_info)

            except Exception as e:
                print(f"‚ö†Ô∏è  Error parsing {python_file}: {e}")
                continue

        self.api_endpoints = endpoints
        return endpoints

    def _extract_class_info(
        self, node: ast.ClassDef, file_path: Path
    ) -> Optional[Dict[str, Any]]:
        """Extract information about a class"""
        docstring = ast.get_docstring(node)

        # Check if this looks like an API-related class
        api_indicators = ["handler", "client", "manager", "service", "api", "interface"]
        class_name_lower = node.name.lower()

        if not any(indicator in class_name_lower for indicator in api_indicators):
            return None

        methods = []
        for item in node.body:
            if isinstance(item, ast.FunctionDef):
                method_info = self._extract_function_info(
                    item, file_path, is_method=True
                )
                if method_info:
                    methods.append(method_info)

        return {
            "type": "class",
            "name": node.name,
            "docstring": docstring or f"API class: {node.name}",
            "file_path": str(file_path.relative_to(self.source_dir)),
            "line_number": node.lineno,
            "methods": methods,
            "bases": [
                base.id if isinstance(base, ast.Name) else str(base)
                for base in node.bases
            ],
        }

    def _extract_function_info(
        self, node: ast.FunctionDef, file_path: Path, is_method: bool = False
    ) -> Optional[Dict[str, Any]]:
        """Extract information about a function or method"""
        docstring = ast.get_docstring(node)

        # Skip private methods and special methods (except __init__)
        if node.name.startswith("_") and node.name != "__init__":
            return None

        # Extract parameters
        parameters = []
        for arg in node.args.args:
            param_info = {"name": arg.arg, "annotation": None, "default": None}

            # Get type annotation if available
            if arg.annotation:
                if isinstance(arg.annotation, ast.Name):
                    param_info["annotation"] = arg.annotation.id
                else:
                    try:
                        param_info["annotation"] = ast.unparse(arg.annotation)
                    except Exception:
                        param_info["annotation"] = str(arg.annotation)

            parameters.append(param_info)

        # Extract defaults
        defaults = node.args.defaults
        if defaults:
            # Match defaults to parameters (defaults are for the last N parameters)
            param_count = len(parameters)
            default_count = len(defaults)
            start_idx = param_count - default_count

            for i, default in enumerate(defaults):
                param_idx = start_idx + i
                if param_idx < len(parameters):
                    try:
                        parameters[param_idx]["default"] = ast.unparse(default)
                    except Exception:
                        parameters[param_idx]["default"] = str(default)

        # Extract return annotation
        return_annotation = None
        if node.returns:
            if isinstance(node.returns, ast.Name):
                return_annotation = node.returns.id
            else:
                try:
                    return_annotation = ast.unparse(node.returns)
                except Exception:
                    return_annotation = str(node.returns)

        return {
            "type": "method" if is_method else "function",
            "name": node.name,
            "docstring": docstring
            or f"{'Method' if is_method else 'Function'}: {node.name}",
            "file_path": str(file_path.relative_to(self.source_dir)),
            "line_number": node.lineno,
            "parameters": parameters,
            "return_annotation": return_annotation,
            "is_async": isinstance(node, ast.AsyncFunctionDef),
        }

    def generate_api_docs(self) -> None:
        """Generate comprehensive API documentation"""
        print("üìö Generating API documentation...")

        # Discover all API components
        self.discover_api_endpoints()

        # Generate overview document
        self._generate_api_overview()

        # Generate detailed documentation for each component
        self._generate_class_docs()
        self._generate_function_docs()

        # Generate index
        self._generate_api_index()

        print(f"‚úÖ API documentation generated in {self.output_dir}")

    def _generate_api_overview(self) -> None:
        """Generate API overview document"""
        content = f"""---
language: ru
type: api
audience: developer
difficulty: intermediate
last_updated: {datetime.now().strftime('%Y-%m-%d')}
english_version: api-overview_EN.md
russian_version: api-overview.md
---

# üîå API –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫: Target Assistant Bot

> **–í–µ—Ä—Å–∏—è API**: v0.2.5  
> **–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ**: {datetime.now().strftime('%Y-%m-%d')}  
> **–°—Ç–∞—Ç—É—Å**: ‚úÖ –°—Ç–∞–±–∏–ª—å–Ω—ã–π

## üìã –û–±–∑–æ—Ä

Target Assistant Bot –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–π API –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ü–µ–ª—è–º–∏, –∑–∞–¥–∞—á–∞–º–∏ –∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –≤–Ω–µ—à–Ω–∏–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏.

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**: Clean Architecture —Å —á–µ—Ç–∫–∏–º —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º —Å–ª–æ–µ–≤
**–¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏**: Python 3.12+, Async/Await, Type Hints

## üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ API

| –ö–æ–º–ø–æ–Ω–µ–Ω—Ç | –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ | –û–ø–∏—Å–∞–Ω–∏–µ |
|-----------|------------|----------|
| **–ö–ª–∞—Å—Å—ã** | {len(self.classes)} | API –∫–ª–∞—Å—Å—ã –∏ —Å–µ—Ä–≤–∏—Å—ã |
| **–§—É–Ω–∫—Ü–∏–∏** | {len(self.functions)} | –ü—É–±–ª–∏—á–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ |
| **Endpoints** | {len(self.api_endpoints)} | –û–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã–µ endpoints |

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ —Å–ª–æ–∏

### üì± Presentation Layer
–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ Telegram –±–æ—Ç–∞ –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–æ–≤

### üîß Application Layer  
–ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞ –∏ –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤

### üíº Domain Layer
–û—Å–Ω–æ–≤–Ω—ã–µ –º–æ–¥–µ–ª–∏ –∏ –±–∏–∑–Ω–µ—Å-–ø—Ä–∞–≤–∏–ª–∞

### üóÑÔ∏è Infrastructure Layer
–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –≤–Ω–µ—à–Ω–∏–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏ (OpenAI, Google Sheets)

## üìö –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã

### üéØ Goal Management API
–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ü–µ–ª—è–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- –°–æ–∑–¥–∞–Ω–∏–µ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–µ–ª–µ–π
- –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
- –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π

### üìù Task Management API
–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∞–º–∏ –≤ —Ä–∞–º–∫–∞—Ö —Ü–µ–ª–µ–π
- –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏
- –°—Ç–∞—Ç—É—Å—ã –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
- –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ

### üß† LLM Integration API
–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —è–∑—ã–∫–æ–≤—ã–º–∏ –º–æ–¥–µ–ª—è–º–∏
- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–ª–∞–Ω–æ–≤
- –ú–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
- –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞

### üìä Analytics API
–°–±–æ—Ä –∏ –∞–Ω–∞–ª–∏–∑ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
- –ú–µ—Ç—Ä–∏–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
- –û—Ç—á–µ—Ç—ã –ø–æ —Ü–µ–ª—è–º
- –ü—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏–µ

## üîê –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è

```python
# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è API
from core.goal_manager import GoalManager
from shared.container.dependency_container import Container

# –ü–æ–ª—É—á–µ–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —á–µ—Ä–µ–∑ DI –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
container = Container()
goal_manager = container.resolve(GoalManager)

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ API
goal = await goal_manager.create_goal(user_id, goal_data)
```

## üìñ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

- [üìã –ö–ª–∞—Å—Å—ã –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã](classes.md)
- [‚ö° –§—É–Ω–∫—Ü–∏–∏ –∏ –º–µ—Ç–æ–¥—ã](functions.md)
- [üß™ –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è](examples.md)

## ü§ù –í–Ω–µ—Å–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π

–ü—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ API –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ:
1. –û–±–Ω–æ–≤–∏—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é
2. –î–æ–±–∞–≤—å—Ç–µ —Ç–µ—Å—Ç—ã
3. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –æ–±—Ä–∞—Ç–Ω—É—é —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å
4. –û–±–Ω–æ–≤–∏—Ç–µ –ø—Ä–∏–º–µ—Ä—ã

---

**üìù –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è:**  
–≠—Ç–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞.
"""

        with open(self.output_dir / "api-overview.md", "w", encoding="utf-8") as f:
            f.write(content)

    def _generate_class_docs(self) -> None:
        """Generate documentation for classes"""
        if not self.classes:
            return

        content = f"""---
language: ru
type: api
audience: developer
difficulty: intermediate
last_updated: {datetime.now().strftime('%Y-%m-%d')}
english_version: classes_EN.md
russian_version: classes.md
---

# üìã API –ö–ª–∞—Å—Å—ã –∏ –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã

> **–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –∫–ª–∞—Å—Å–æ–≤**: {len(self.classes)}  
> **–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ**: {datetime.now().strftime('%Y-%m-%d')}

## üìö –°–ø–∏—Å–æ–∫ –∫–ª–∞—Å—Å–æ–≤

"""

        for class_info in sorted(self.classes, key=lambda x: x["name"]):
            content += f"""
### üèóÔ∏è `{class_info['name']}`

**–§–∞–π–ª**: `{class_info['file_path']}`  
**–°—Ç—Ä–æ–∫–∞**: {class_info['line_number']}

**–û–ø–∏—Å–∞–Ω–∏–µ**: {class_info['docstring']}

"""
            if class_info["bases"]:
                content += f"**–ù–∞—Å–ª–µ–¥—É–µ—Ç—Å—è –æ—Ç**: {', '.join(class_info['bases'])}\n\n"

            if class_info["methods"]:
                content += "**–ú–µ—Ç–æ–¥—ã**:\n"
                for method in class_info["methods"]:
                    async_marker = "async " if method.get("is_async") else ""
                    params = ", ".join(
                        [p["name"] for p in method.get("parameters", [])]
                    )
                    return_type = (
                        f" -> {method['return_annotation']}"
                        if method.get("return_annotation")
                        else ""
                    )

                    content += (
                        f"- `{async_marker}{method['name']}({params}){return_type}`\n"
                    )
                    if method["docstring"]:
                        content += f"  - {method['docstring']}\n"
                content += "\n"

        content += f"""
---

**üìù –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è:**  
–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞.
"""

        with open(self.output_dir / "classes.md", "w", encoding="utf-8") as f:
            f.write(content)

    def _generate_function_docs(self) -> None:
        """Generate documentation for functions"""
        if not self.functions:
            return

        content = f"""---
language: ru
type: api
audience: developer
difficulty: intermediate
last_updated: {datetime.now().strftime('%Y-%m-%d')}
english_version: functions_EN.md
russian_version: functions.md
---

# ‚ö° API –§—É–Ω–∫—Ü–∏–∏ –∏ –º–µ—Ç–æ–¥—ã

> **–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ —Ñ—É–Ω–∫—Ü–∏–π**: {len(self.functions)}  
> **–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ**: {datetime.now().strftime('%Y-%m-%d')}

## üìö –°–ø–∏—Å–æ–∫ —Ñ—É–Ω–∫—Ü–∏–π

"""

        for func_info in sorted(self.functions, key=lambda x: x["name"]):
            async_marker = "async " if func_info.get("is_async") else ""
            params = ", ".join(
                [
                    f"{p['name']}: {p.get('annotation', 'Any')}"
                    + (f" = {p['default']}" if p.get("default") else "")
                    for p in func_info.get("parameters", [])
                ]
            )
            return_type = (
                f" -> {func_info['return_annotation']}"
                if func_info.get("return_annotation")
                else ""
            )

            content += f"""
### ‚ö° `{async_marker}{func_info['name']}({params}){return_type}`

**–§–∞–π–ª**: `{func_info['file_path']}`  
**–°—Ç—Ä–æ–∫–∞**: {func_info['line_number']}

**–û–ø–∏—Å–∞–Ω–∏–µ**: {func_info['docstring']}

"""

            if func_info.get("parameters"):
                content += "**–ü–∞—Ä–∞–º–µ—Ç—Ä—ã**:\n"
                for param in func_info["parameters"]:
                    param_type = param.get("annotation", "Any")
                    default_info = (
                        f" (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: {param['default']})"
                        if param.get("default")
                        else ""
                    )
                    content += f"- `{param['name']}: {param_type}` {default_info}\n"
                content += "\n"

        content += f"""
---

**üìù –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è:**  
–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞.
"""

        with open(self.output_dir / "functions.md", "w", encoding="utf-8") as f:
            f.write(content)

    def _generate_api_index(self) -> None:
        """Generate API documentation index"""
        content = f"""---
language: ru
type: api
audience: developer
difficulty: beginner
last_updated: {datetime.now().strftime('%Y-%m-%d')}
english_version: README_EN.md
russian_version: README.md
---

# üìö API –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è - Target Assistant Bot

> **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ  
> **–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## üéØ –ë—ã—Å—Ç—Ä–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è

| –†–∞–∑–¥–µ–ª | –û–ø–∏—Å–∞–Ω–∏–µ | –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ |
|--------|----------|------------|
| [üìã –û–±–∑–æ—Ä API](api-overview.md) | –û–±—â–µ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã | - |
| [üèóÔ∏è –ö–ª–∞—Å—Å—ã](classes.md) | API –∫–ª–∞—Å—Å—ã –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã | {len(self.classes)} |
| [‚ö° –§—É–Ω–∫—Ü–∏–∏](functions.md) | –ü—É–±–ª–∏—á–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ | {len(self.functions)} |

## üöÄ –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç

```python
# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ API
from core.goal_manager import GoalManager
from shared.container.dependency_container import Container

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ DI –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
container = Container()
goal_manager = container.resolve(GoalManager)

# –°–æ–∑–¥–∞–Ω–∏–µ —Ü–µ–ª–∏
goal_data = {{
    "title": "–ò–∑—É—á–∏—Ç—å Python",
    "deadline": "2025-07-01",
    "priority": "high"
}}

goal = await goal_manager.create_goal(user_id=123, goal_data=goal_data)
```

## üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏

- **–í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **–ö–ª–∞—Å—Å–æ–≤ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ**: {len(self.classes)}
- **–§—É–Ω–∫—Ü–∏–π –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ**: {len(self.functions)}
- **Endpoints –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ**: {len(self.api_endpoints)}
- **–§–∞–π–ª–æ–≤ –ø—Ä–æ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ**: {len(list(self.source_dir.rglob("*.py")))}

## üîÑ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ

–≠—Ç–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ API.
–î–ª—è —Ä—É—á–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤—ã–ø–æ–ª–Ω–∏—Ç–µ:

```bash
python .github/scripts/api-doc-generator.py
```

---

**üîó –ù–∞–≤–∏–≥–∞—Ü–∏—è:**
- üè† [–ì–ª–∞–≤–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è](../../README.md)
- ü§ù [–£—á–∞—Å—Ç–∏–µ –≤ –ø—Ä–æ–µ–∫—Ç–µ](../../CONTRIBUTING.md)
- üîß [–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞](../../DEVELOPMENT_CHECKLIST.md)
"""

        with open(self.output_dir / "README.md", "w", encoding="utf-8") as f:
            f.write(content)

    def generate_statistics_report(self) -> Dict[str, Any]:
        """Generate statistics about API documentation generation"""
        python_files = list(self.source_dir.rglob("*.py"))
        total_files = len(python_files)

        report = {
            "timestamp": datetime.now().isoformat(),
            "statistics": {
                "total_python_files": total_files,
                "classes_found": len(self.classes),
                "functions_found": len(self.functions),
                "endpoints_found": len(self.api_endpoints),
                "documentation_files_generated": 4,  # overview, classes, functions, index
            },
            "files_scanned": [
                str(f.relative_to(self.source_dir)) for f in python_files
            ],
            "output_directory": str(self.output_dir),
        }

        return report


def main():
    """Main execution function"""
    print("üîå API Documentation Generator")
    print("=" * 50)

    generator = APIDocumentationGenerator()

    # Generate all API documentation
    generator.generate_api_docs()

    # Generate statistics report
    report = generator.generate_statistics_report()

    # Save statistics
    with open("api-doc-generation-report.json", "w", encoding="utf-8") as f:
        json.dump(report, f, indent=2, ensure_ascii=False)

    print("\nüìä GENERATION STATISTICS:")
    stats = report["statistics"]
    print(f"   Total Python files: {stats['total_python_files']}")
    print(f"   Classes documented: {stats['classes_found']}")
    print(f"   Functions documented: {stats['functions_found']}")
    print(f"   Endpoints discovered: {stats['endpoints_found']}")
    print(f"   Documentation files: {stats['documentation_files_generated']}")

    print("\nüìÑ Statistics report saved to: api-doc-generation-report.json")
    print("‚úÖ API documentation generation complete!")


if __name__ == "__main__":
    main()
